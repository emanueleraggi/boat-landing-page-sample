{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = separateStyles;\n\nvar _object = _interopRequireDefault(require(\"object.assign\"));\n\nvar _has = _interopRequireDefault(require(\"has\")); // This function takes the array of styles and separates them into styles that\n// are handled by Aphrodite and inline styles.\n\n\nfunction separateStyles(stylesArray) {\n  var aphroditeStyles = []; // Since determining if an Object is empty requires collecting all of its\n  // keys, and we want the best performance in this code because we are in the\n  // render path, we are going to do a little bookkeeping ourselves.\n\n  var hasInlineStyles = false;\n  var inlineStyles = {}; // This is run on potentially every node in the tree when rendering, where\n  // performance is critical. Normally we would prefer using `forEach`, but\n  // old-fashioned for loops are faster so that's what we have chosen here.\n\n  for (var i = 0; i < stylesArray.length; i += 1) {\n    var style = stylesArray[i]; // If this  style is falsey, we just want to disregard it. This allows for\n    // syntax like:\n    //\n    //   css(isFoo && styles.foo)\n\n    if (style) {\n      if ((0, _has[\"default\"])(style, '_name') && (0, _has[\"default\"])(style, '_definition')) {\n        aphroditeStyles.push(style);\n      } else {\n        (0, _object[\"default\"])(inlineStyles, style);\n        hasInlineStyles = true;\n      }\n    }\n  }\n\n  return {\n    aphroditeStyles: aphroditeStyles,\n    hasInlineStyles: hasInlineStyles,\n    inlineStyles: inlineStyles\n  };\n}","map":{"version":3,"sources":["/home/labrat/Desktop/boat-landing-page-sample/client/node_modules/react-with-styles-interface-aphrodite/lib/utils/separateStyles.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","separateStyles","_object","_has","stylesArray","aphroditeStyles","hasInlineStyles","inlineStyles","i","length","style","push"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAAD,CAApC;;AAEAC,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAAC,SAAD,CAAP,GAAqBE,cAArB;;AAEA,IAAIC,OAAO,GAAGP,sBAAsB,CAACC,OAAO,CAAC,eAAD,CAAR,CAApC;;AAEA,IAAIO,IAAI,GAAGR,sBAAsB,CAACC,OAAO,CAAC,KAAD,CAAR,CAAjC,C,CAEA;AACA;;;AACA,SAASK,cAAT,CAAwBG,WAAxB,EAAqC;AACnC,MAAIC,eAAe,GAAG,EAAtB,CADmC,CACT;AAC1B;AACA;;AAEA,MAAIC,eAAe,GAAG,KAAtB;AACA,MAAIC,YAAY,GAAG,EAAnB,CANmC,CAMZ;AACvB;AACA;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,WAAW,CAACK,MAAhC,EAAwCD,CAAC,IAAI,CAA7C,EAAgD;AAC9C,QAAIE,KAAK,GAAGN,WAAW,CAACI,CAAD,CAAvB,CAD8C,CAClB;AAC5B;AACA;AACA;;AAEA,QAAIE,KAAJ,EAAW;AACT,UAAI,CAAC,GAAGP,IAAI,CAAC,SAAD,CAAR,EAAqBO,KAArB,EAA4B,OAA5B,KAAwC,CAAC,GAAGP,IAAI,CAAC,SAAD,CAAR,EAAqBO,KAArB,EAA4B,aAA5B,CAA5C,EAAwF;AACtFL,QAAAA,eAAe,CAACM,IAAhB,CAAqBD,KAArB;AACD,OAFD,MAEO;AACL,SAAC,GAAGR,OAAO,CAAC,SAAD,CAAX,EAAwBK,YAAxB,EAAsCG,KAAtC;AACAJ,QAAAA,eAAe,GAAG,IAAlB;AACD;AACF;AACF;;AAED,SAAO;AACLD,IAAAA,eAAe,EAAEA,eADZ;AAELC,IAAAA,eAAe,EAAEA,eAFZ;AAGLC,IAAAA,YAAY,EAAEA;AAHT,GAAP;AAKD","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = separateStyles;\n\nvar _object = _interopRequireDefault(require(\"object.assign\"));\n\nvar _has = _interopRequireDefault(require(\"has\"));\n\n// This function takes the array of styles and separates them into styles that\n// are handled by Aphrodite and inline styles.\nfunction separateStyles(stylesArray) {\n  var aphroditeStyles = []; // Since determining if an Object is empty requires collecting all of its\n  // keys, and we want the best performance in this code because we are in the\n  // render path, we are going to do a little bookkeeping ourselves.\n\n  var hasInlineStyles = false;\n  var inlineStyles = {}; // This is run on potentially every node in the tree when rendering, where\n  // performance is critical. Normally we would prefer using `forEach`, but\n  // old-fashioned for loops are faster so that's what we have chosen here.\n\n  for (var i = 0; i < stylesArray.length; i += 1) {\n    var style = stylesArray[i]; // If this  style is falsey, we just want to disregard it. This allows for\n    // syntax like:\n    //\n    //   css(isFoo && styles.foo)\n\n    if (style) {\n      if ((0, _has[\"default\"])(style, '_name') && (0, _has[\"default\"])(style, '_definition')) {\n        aphroditeStyles.push(style);\n      } else {\n        (0, _object[\"default\"])(inlineStyles, style);\n        hasInlineStyles = true;\n      }\n    }\n  }\n\n  return {\n    aphroditeStyles: aphroditeStyles,\n    hasInlineStyles: hasInlineStyles,\n    inlineStyles: inlineStyles\n  };\n}"]},"metadata":{},"sourceType":"script"}